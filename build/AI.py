import subprocess

try:
    import nltk
    import sklearn
    import pandas
    import docx
except ModuleNotFoundError:
    print("NLTK is not installed. Installing...")
    subprocess.check_call(["pip", "install", "nltk"])
    subprocess.check_call(["pip","install","scikit-learn"])
    subprocess.check_call(["pip","install","pandas"])
    subprocess.check_call(["pip","install","python-docx"])
    import nltk
    import sklearn
    import pandas
    import docx
import tkinter as tk
from tkinter import filedialog
import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
import pandas as pd
import pickle
from docx import Document
import os
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage


OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"C:\Users\USER\Documents\Projects\Major Project\Skive\NewDirectory\Profile\Task assignment tool\build\assets\frame0")


def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)

# Download NLTK resources (if not already downloaded)
nltk.download('punkt')
nltk.download('stopwords')
nltk.download('wordnet')
script_dir = os.path.dirname(os.path.realpath(__file__))
sub_dir = "assets\\final_combined_dataset_skive.csv"
full_path = os.path.join(script_dir,sub_dir)
# Now 'script_dir' contains the directory path of the current Python script

# Load and preprocess dataset
dataset = pd.read_csv(full_path)

# Function to handle NaN values and preprocess text
def preprocess_text(text):
    if pd.isnull(text):
        return ""
    else:
        tokens = word_tokenize(text)
        tokens = [word for word in tokens if word.isalnum()]
        stop_words = set(stopwords.words('english'))
        tokens = [word for word in tokens if not word in stop_words]
        lemmatizer = WordNetLemmatizer()
        tokens = [lemmatizer.lemmatize(word.lower()) for word in tokens]
        return ' '.join(tokens)

# Apply preprocessing to problem statements
dataset['processed_statement'] = dataset['problem_statement'].apply(preprocess_text)

# Fill NaN values in dataset
dataset.fillna('', inplace=True)  # Replace NaN values with an empty string

# Vectorize problem statements using TF-IDF
tfidf_vectorizer = TfidfVectorizer(max_features=1000)
X = tfidf_vectorizer.fit_transform(dataset['processed_statement'])
y = dataset['required_skills']

# Train Support Vector Machine (SVM) classifier
svm_classifier = SVC(kernel='linear')
svm_classifier.fit(X, y)

# Save the trained vectorizer and classifier
with open('vectorizer.pkl', 'wb') as f:
    pickle.dump(tfidf_vectorizer, f)

with open('classifier.pkl', 'wb') as f:
    pickle.dump(svm_classifier, f)

# Function to extract text from Word document
def extract_text_from_docx(file_path):
    doc = Document(file_path)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return '\n'.join(full_text)

# Function to predict required skills
def predict_required_skills(problem_statement):
    processed_statement = preprocess_text(problem_statement)
    vectorized_statement = tfidf_vectorizer.transform([processed_statement])
    predicted_skills = svm_classifier.predict(vectorized_statement)
    return predicted_skills

# GUI application
def upload_document():
    file_path = filedialog.askopenfilename(filetypes=[("Word documents", "*.docx"), ("All files", "*.*")])
    if file_path:
        try:
            document_text = extract_text_from_docx(file_path)
            predicted_skills = predict_required_skills(document_text)
            skills_text = ', '.join(predicted_skills)
            canvas.itemconfig(result_label,text="" + str(skills_text))
            print("Problem Statement:")
            print(document_text)
            print("Required Skills =" +skills_text)
        except Exception as e:
            print("Error occurred:", e)

window = Tk()

window.geometry("510x450")
window.configure(bg = "#3A868F")

# Create and place widgets
#upload_button = tk.Button(window, text="Upload Document", command=upload_document)
#upload_button.pack(pady=20)

#result_label = tk.Label(window, text="")
#result_label.pack()

canvas = Canvas(
    window,
    bg = "#3A868F",
    height = 450,
    width = 510,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
image_image_1 = PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    255.0,
    225.0,
    image=image_image_1
)

canvas.create_rectangle(
    17.0,
    11.0,
    493.0,
    165.0,
    fill="#225777",
    outline="")

canvas.create_text(
    35.0,
    26.0,
    anchor="nw",
    text="Task Assignment Tool",
    fill="#ECECD9",
    font=("Libre Caslon Text", 19 * -1)
)

canvas.create_text(
    35.0,
    71.0,
    anchor="nw",
    text="Choose Document \nfrom Files:-",
    fill="#FFFFFF",
    font=("Libre Caslon Text", 14 * -1)
)

canvas.create_text(
    35.0,
    113.0,
    anchor="nw",
    text="Skills Required :-",
    fill="#FFFFFF",
    font=("Libre Caslon Text", 14 * -1)
)

result_label=canvas.create_text(
    159.0,
    113.0,
    anchor="nw",
    text="",
    fill="#FFFFFF",
    font=("Libre Caslon Text", 14 * -1)
)

button_image_1 = PhotoImage(
    file=relative_to_assets("button_1.png"))
upload_button = Button(
    image=button_image_1,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: upload_document(),
    relief="flat"
)
upload_button.place(
    x=199.0,
    y=71.0,
    width=192.0,
    height=36.0
)

canvas.create_rectangle(
    17.0,
    181.0,
    493.0,
    433.0,
    fill="#D9D9D9",
    outline="")

canvas.create_rectangle(
    33.0,
    197.0,
    479.0,
    278.0,
    fill="#173054",
    outline="")

canvas.create_rectangle(
    33.0,
    284.0,
    479.0,
    365.0,
    fill="#173054",
    outline="")


# Run the GUI application
window.mainloop()
